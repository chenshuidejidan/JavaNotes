# MVC 和 三层架构
## MVC
Model View Controllor(模型，视图和控制器)，是一种web软件的开发模式    

- **模型(Model)：** 表示底层的数据
- **视图(View)：** 可视化方式向用户展示模型
- **控制器(Controllor)：** 根据用户输入来对模型修行修改 

**优点：** 低耦合，方便维护，有利于分工合作，重用性高           
**缺点：** 项目架构变得复杂         

## 三层架构  
软件设计架构            
- 视图层、界面层(View层/web层)：接收用户请求，用户可以通过界面上的组件和服务器进行交互
- 服务层、业务逻辑层(Service层)：系统的业务逻辑      
- 持久层、数据访问层(Dao层)：直接操作数据库      

![三层架构.png](https://s1.ax1x.com/2020/08/20/d3j1BD.png)

为了更好的降低各层间的耦合度，在三层架构程序设计中，采用**面向抽象编程**。即上层对下层的调用，是通过**接口**实现的。而下层对上层的真正服务提供者，是下层**接口的实现类**        

## MVC与三层架构的关系
三层架构中的View层简单的说就是跟用户发生直接关系的层，MVC中的V和C就是这样的存在，所以MVC中的V和C均属于三层架构的View层。同时，我们知道MVC中的M（Model）包括了数据承载Bean和业务处理Bean，其中业务处理Bean分为Service或Dao对象，分别对应业务逻辑处理和数据库操作，相应的，它们对应的是三层架构中的Service层和Dao层
<img src="https://s1.ax1x.com/2020/08/20/d3LGAs.png" alt="MVC和三层架构的关系.png" style="zoom:80%;" />

## 三层架构和各个框架的关系
<img src="https://s1.ax1x.com/2020/09/22/wXPDB9.png" alt="wXPDB9.png"  />

# MyBatis
- **mybatis** 是优秀的java**持久层框架**，内部**封装了jdbc操作的很多细节**，开发者只需要关注sql本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程，它使用**ORM(Object Realtional Mapping 对象关系映射)** 思想实现了结果集的封装。
- **Hibernate** 也是持久层的一个解决方案

## 1. 原始jdbc存在的问题
- 数据库连接创建、释放频繁造成系统资源浪费影响系统性能------使用数据库连接池
- sql语句硬编码，不易维护，变动需要改变java代码------将sql语句抽取到xml配置文件中
- 查询结果需要手动封装到实体中，插入操作需要手动将实体数据设置到sql语句的占位------利用反射、内省等底层技术实现实体属性和表字段的映射

## 2. QuickStart 和 自定义mybatis功能
### 2.1 QuickStart-xml配置
1. 添加MyBatis的坐标
2. 创建user数据表
3. 创建实体类和Dao接口
4. 创建映射配置文件 IUserDao.xml
5. 创建mybatis主配置文件 SqlMapConfig.xml
6. 测试

**注意：**
1. 在Mybatis中，持久层的操作接口名称和映射文件也叫**Mapper**： IUserDao.xml  也写作 IUserMapper.xml
2. idea中创建目录的时候和包不同，包在创建com.jj.dao是三级结构，但是创建目录是一级结构：IUserDao.xml的目录**必须一级一级的创建**
3. mybatis的映射配置文件结构必须要和dao接口的包接口相同： `main/java/com/jj/dao/IUserDao`  和  `resources/com/jj/dao/IUserDao.xml`  必须一一对应
4. 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名
5. 映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名

遵守345规则之后，开发中无需再写dao的实现类了！
- **核心配置文件：sqlMapConfig.xml**
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
 <!-- mybatis的主配置文件 -->
<configuration>
    <!-- 配置环境 -->
    <environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务的类型-->
            <transactionManager type="JDBC"></transactionManager>
            <!-- 配置数据源（连接池） -->
            <dataSource type="POOLED">
                <!-- 配置连接数据库的4个基本信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
                <property name="username" value="root"/>
                <property name="password" value="janshan123"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 使用xml配置时：指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
         使用注解配置时：使用class属性指定被注解的dao的全限定类名
    -->
    <mappers>
        <mapper resource="com/jj/dao/IUserDao.xml"/>
        <!-- <mapper class="com.jj.dao.IUserDao"/> -->
    </mappers>
</configuration>
~~~
- **Mapper的配置：IUserDao.xml**
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.jj.dao.IUserDao">
    <!--配置查询所有-->
    <select id="findAll" resultType="com.jj.domain.User">
        select * from user
    </select>
</mapper>
~~~

- 测试步骤如下：
~~~java
    public void test1() throws IOException {
        //1. 加载核心配置文件
        InputStream inputStream = Resources.getResourceAsStream("sqlMapConfig.xml");
        
        //2. 创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(inputStream);
        
        //3. 使用工厂生产SqlSession对象
        SqlSession session = factory.openSession();
        
        //4. 使用SqlSession创建Dao接口的代理对象
        IUserDao userDao = session.getMapper(IUserDao.class);
        
        //5. 使用代理对象执行Dao中的方法
        List<User> users = userDao.findAll();
        for(User user: users){
            System.out.println(user);
        }
        
        //6. 释放资源
        session.close();
        inputStream.close();
    }
~~~

#### 2.1.1 测试步骤详解
1. 加载核心配置文件
   - 使用绝对路径的写法不具有通用性，而相对路径写法在部署后src目录也没了，也不适用。均不使用
   - **使用类加载器：** 只能读取类路径的配置文件
   - **使用ServletContext对象的getRealPath()** 

2. 创建SqlSessionFactory工厂
   - 创建工厂时，mybatis使用了构建者模式：把对象的创建细节隐藏，使使用者直接调用方法即可拿到对象

3. 使用工厂生产SqlSession对象
   - 使用工厂模式生产session：解耦，降低类之间的依赖关系

4. 使用SqlSession创建Dao接口的代理对象
   - 使用了代理模式：不修改源码的基础上增强已有方法



### 2.2 QuickStart-注解配置
- Dao接口使用注解配置
~~~java
public interface IUserDao {
    @Seleect("select * from user")
    List<User> findAll();
}
~~~

- 移除mapper的配置文件IUserDao.xml，对mybatis主配置文件进行修改
~~~xml
...
  <configuration>
    ...

    <!-- 使用xml配置时：指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件
         使用注解配置时：使用class属性指定被注解的dao接口的全限定类名
    -->
    <mappers>
        <!-- <mapper resource="com/jj/dao/IUserDao.xml"/> -->
        <mapper class="com.jj.dao.IUserDao"/>
    </mappers>
  </configuration>
~~~

### 2.3 自定义MyBatis

![配置文件详解](https://s1.ax1x.com/2020/09/24/wzMseA.png)
![步骤](https://s1.ax1x.com/2020/09/24/0pn8d1.png)
- 读取配置信息到Configuration类，使用Mapper存储sql语句和结果类型
~~~java
/**
 * 自定义mybatis的配置类
 */
public class Configuration {
    private String driver;
    private String url;
    private String username;
    private String password;
    private Map<String, Mapper> mappers = new HashMap<String, Mapper>();
    ...
}

/**
 * 用于封装执行的sql语句和结果类型的全限定类名
 */
public class Mapper {
    public String queryString;  //sql
    public String resultType;   //实体类的全限定类名
~~~

- 创建获取SqlSession对象的工厂
~~~java
public class SqlSessionFactoryBuilder {
    public SqlSessionFactory build(InputStream inputStream){
        Configuration config = XMLConfigBuilder.loadConfiguration(inputStream);
        return new DefaultSqlSessionFactory(config);
    }
}
~~~
~~~java
public class DefaultSqlSessionFactory implements SqlSessionFactory {
    private Configuration config;
    public DefaultSqlSessionFactory(Configuration config){
        this.config = config;
    }

    public SqlSession openSession() {
        return new DefaultSqlSession(config);
    }
}
~~~

- SqlSession执行功能
~~~java
public class DefaultSqlSession implements SqlSession {
    private Configuration cfg;
    private Connection conn;    //数据库连接对象

    public DefaultSqlSession(Configuration cfg){
        this.cfg = cfg;
        conn = DataSourceUtil.getConnection(cfg);
    }

    public <T> T getMapper(Class<T> daoInterfaceClass) {  //使用代理对象完成功能
        return (T) Proxy.newProxyInstance(daoInterfaceClass.getClassLoader(), new Class[]{daoInterfaceClass}, new MapperProxy(cfg.getMappers(), conn));
    }

    public void close() {
        if (conn!=null) {
            try {
                conn.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
~~~

- MapperProxy代理对象

~~~java
public class MapperProxy implements InvocationHandler {
    private final Map<String, Mapper> mappers;
    private Connection conn;

    public MapperProxy(Map<String, Mapper> mappers, Connection conn) {
        this.mappers = mappers;
        this.conn = conn;
    }
    /**
     *调用selectList
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //1. 获取方法名
        String methodName = method.getName();
        //2. 获取方法所在类名
        String className = method.getDeclaringClass().getName();
        //3. 组合key
        String key = className+"."+methodName;
        //4. 获取key对应的mapper
        Mapper mapper = mappers.get(key);
        //5. 判断是否存在
        if(mapper==null){
            throw new IllegalArgumentException("传入的参数有误");
        }
        //6. 调用工具类执行查询所有
        return new Executor().selectList(mapper, conn);
    }
}
~~~

- 使用注解的方式

~~~java
/**
 * 查询的注解
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Select {
    String value();
}
~~~

## 3. mybatis的CRUD 
- 模糊查询 `select * from user where username like #{name}` 使用的是preparedStatement的参数占位符方式`?`
- 模糊查询 `select * from user where username like '%${value}%'` 使用的是字符串拼接的Statement
- 保存用户后获取保存的用户的id: `select last_insert_id();`
~~~xml
        <selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
~~~
- **OGNL表达式：** Object Graphic Navigation Language 对象图导航语言，**通过对象的取值方法来获取数据**，把get给省略了，而parameterType中已经提供了属性所属的类，所以直接写属性名即可  
~~~java
user.getUsername();   //类中的写法
user.username         //OGNL表达式
~~~
~~~xml
    <!-- parameterType已提供类名，所以查询语句里面只需要写属性名即可 -->
    <select id="findById" parameterType="INT" resultMap="userMap">   
        select * from user where id = #{uid}
    </select>
~~~

- **如果类的属性名和数据库的列名不匹配：** 
  - 查询时起别名：`select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;`
  - 或者配置查询结果的列名和实体类属性名的对应关系，并配置查询的reusltMap
  ~~~xml
    <!-- 配置 查询结果的列名和实体类的属性名的对应关系 -->
    <resultMap id="userMap" type="uSeR">
        <!-- 主键字段的对应 -->
        <id property="userId" column="id"></id>
        <!--非主键字段的对应-->
        <result property="userName" column="username"></result>
        <result property="userAddress" column="address"></result>
        <result property="userSex" column="sex"></result>
        <result property="userBirthday" column="birthday"></result>
    </resultMap>
  
    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        select * from user;
    </select>
  ~~~

- CRUD
~~~xml
    <!-- 查询所有 -->
    <select id="findAll" resultMap="userMap">
        <!--select id as userId,username as userName,address as userAddress,sex as userSex,birthday as userBirthday from user;-->
        select * from user;
    </select>

    <!-- 保存用户 -->
    <insert id="saveUser" parameterType="user">
        <!-- 配置插入操作后，获取插入数据的id -->
        <selectKey keyProperty="userId" keyColumn="id" resultType="int" order="AFTER">
            select last_insert_id();
        </selectKey>
        insert into user(username,address,sex,birthday)values(#{userName},#{userAddress},#{userSex},#{userBirthday});
    </insert>

    <!-- 更新用户 -->
    <update id="updateUser" parameterType="USER">
        update user set username=#{userName},address=#{userAddress},sex=#{userSex},birthday=#{userBirthday} where id=#{userId}
    </update>

    <!-- 删除用户-->
    <delete id="deleteUser" parameterType="java.lang.Integer">
        delete from user where id = #{uid}
    </delete>
    
    <!-- 根据id查询用户 -->
    <select id="findById" parameterType="INT" resultMap="userMap">
        select * from user where id = #{uid}
    </select>

    <!-- 根据名称模糊查询 -->
    <select id="findByName" parameterType="string" resultMap="userMap">
          select * from user where username like #{name}
        <!-- select * from user where username like '%${value}%'-->
   </select>

    <!-- 获取用户的总记录条数 -->
    <select id="findTotal" resultType="int">
        select count(id) from user;
    </select>

    <!-- OGNL应用：根据queryVo的条件查询用户(QueryVo中有User的对象)，实现多对象查询 -->
    <select id="findUserByVo" parameterType="com.jj.domain.QueryVo" resultMap="userMap">
        select * from user where username like #{user.username}
    </select>
~~~
- 测试
~~~java
    @Before//用于在测试方法执行之前执行
    public void init()throws Exception{
        //1.读取配置文件，生成字节输入流
        in = Resources.getResourceAsStream("SqlMapConfig.xml");
        //2.获取SqlSessionFactory
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.获取SqlSession对象
        sqlSession = factory.openSession();
        //4.获取dao的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destroy()throws Exception{
        //****************************************提交事务
        sqlSession.commit();
        //6.释放资源
        sqlSession.close();
        in.close();
    }

    @Test
    ...
~~~
## 4. 主配置文件中的其他配置
数据库配置可以外置：

对于SqlMapConfig.xml，可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息
~~~xml
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mydb
jdbc.username=root
jdbc.password=root
~~~
- resource属性：用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。
- url属性：是要求按照Url的写法来写地址(协议 主机 端口 URI)  http://localhost:8080/mybatisserver/demo1Servlet ，本地文件用的是file协议，端口默认：file:///+绝对路径
~~~xml
<configuration>
    <!--使用resource属性配置-->
    <properties resource="jdbcConfig.properties">
    </properties>

    <!--配置环境-->
    <environments default="mysql">
        <!-- 配置mysql的环境-->
        <environment id="mysql">
            <!-- 配置事务 -->
            <transactionManager type="JDBC"></transactionManager>

            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.username}"></property>
                <property name="password" value="${jdbc.password}"></property>
            </dataSource>
        </environment>
    </environments>
</configuration>
~~~
~~~xml
    <!--使用url属性配置-->
    <properties url="file:///D:/Java/05-Mybatis/.../src/main/resources/jdbcConfig.properties">
    </properties>
~~~

- 可以使用typeAliases配置别名(只能配置domain中的类的别名)
~~~xml
<typeAlias type="com.jj.domain.User" alias="user"></typeAlias>
~~~
- 也可以**用package属性指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写！！！！**
~~~xml
<package name="com.jj.domain"></package>
~~~

- **Mappers还可以直接用package配置，指定dao接口所在的包，指定了之后就不需要再写mapper resource/class 了！！！！**
~~~xml
    <mappers>
        <!--<mapper resource="com/jj/dao/IUserDao.xml"></mapper>-->
        <!--<mapper class="com.jj.dao.IUserDao"/>-->
        <package name="com.jj.dao"></package>
    </mappers>
~~~

## 5. 连接池
- 连接池可以减少获取连接所消耗的时间，经常应用到实际开发中
- 连接池就是一个集合对象(容器)，该集合必须是**线程安全**的，两个线程不能获取到同一个连接，同时还要实现**队列**的特性

### 5.1 连接池的配置
在主配置文件中 `SqlMapConfig.xml` 中的`dataSource`标签，type属性表示使用哪种连接池
~~~xml
            <!--配置连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"></property>
                <property name="url" value="${jdbc.url}"></property>
                <property name="username" value="${jdbc.username}"></property>
                <property name="password" value="${jdbc.password}"></property>
            </dataSource>
~~~
- `POOLED`：采用传统的`javax.sql.DataSource` 规范的连接池，mybatis针对该规范进行实现
- `UNPOOLED`：采用传统的获取连接的方式，虽然也实现了`javax.sql.DataSource`接口，但是**没有使用池思想** 
- `JNDI`：采用服务器提供的`JNDI`技术实现，来获取`DataSource`对象，不同服务器拿到的DataSource不同(只有web或maven的war工程才能使用)

### 5.2 POOLED
![POOLED](https://s1.ax1x.com/2020/09/24/0pN5gs.png)
- mybatis内部定义了实现java.sql.DataSource接口的 `PooledDataSource` 类来表示POOLED类型的数据源
![POOLED.jpg](https://s1.ax1x.com/2020/09/24/0pUqsI.jpg)
- 空闲池还有连接直接拿来用，否则去看活动池是否达到最大数量，未达到则创建新的连接，达到了就获取活动连接池最老的一个连接
### 5.3 UNPOOLED
![UNPOOLED](https://s1.ax1x.com/2020/09/24/0pN43j.png)
- mybatis内部定义了实现java.sql.DataSource接口的 `UnpooledDataSource` 类来表示UMPOOLED类型的数据源

### 5.3 JNDI
- 模拟的是windows的注册表
- key：路径+名称(路径固定，name可以指定)  value：数据(JNDI中就是存的对象)



## 6. 事务控制
- 什么是事务？四大特性ACID？不考虑隔离性会产生的3个问题？四种隔离级别？
- 通过`sqlSession` 对象的`commit`方法和`rollback`方法来实现事务的提交和回滚
- **默认是手动提交**，可以设置为自动提交：`sqlSession = factory.openSession(true)`

## 7. 动态sql语句(XML配置)
- 可以使用 `if` 、 `where` 、`foreach` 标签

### 7.1 if 标签
- 使用 `test` 属性来进行条件的判断，注意改造原本的sql语句：加上 `where 1=1`
~~~java
//根据条件查询，可能有用户名，可能有性别，可能有地址
List<User> findUserByCondition(User user);
~~~
~~~xml
<!--使用条件查询-->
<select id="findUserByCondition" resultMap="userMap">
    select * from user where 1=1
    <if test="username!=null">
      and username=#{username}
    </if>
    <if test="sex!=null">
      and sex=#{sex}
    </if>
    <if test="address!=null">
      and address=#{address}
    </if>
</select>
~~~

### 7.2 where 标签
- 使用where标签套if标签，无需改造无条件的sql语句，使得原本的sql语句更简洁
~~~xml
<!--使用条件查询-->
<select id="findUserByCondition" resultMap="userMap">
    select * from user
    <where>
        <if test="username!=null">
          and username=#{username}
        </if>
        <if test="sex!=null">
          and sex=#{sex}
        </if>
        <if test="address!=null">
          and address=#{address}
        </if>
    <where>
</select>
~~~

### 7.3 foreach 标签
- 使用foreach标签实现范围查询
~~~xml
<select id="findUserInIds" parameterType="queryvo" resultMap="userMap">
    select * from user
    <where>
        <if test="ids!=null and ids.size>0">
            <foreach collection="ids" open="and id in(" close=")" item="id" separator=",">
                #{id}
            </foreach>
        </if>
    <where>
</select>
~~~

## 8. 多表查询
https://blog.csdn.net/qq_34332010/article/details/77284744  

查询方法
- 新建一个domain的实体类，将需要的多表联合信息封装进实体类(不常用)
- 使用collection 和 association 建立主表和从表之间的关系

一般使用第二种方法
- 关联 - association 【多对一】
- 集合 - collection 【一对多】


下面是用户表和账户表，一个用户可以有多个账户
| id  | username | birthday            | sex | address    |
| --- | -------- | ------------------- | --- | ---------- |
| 41  | 老王     | 2018-02-27 17:47:08 | 男  | 北京       |
| 45  | 老李     | 2018-03-04 12:04:06 | 男  | 上海       |
| 46  | 老王     | 2018-03-07 17:37:26 | 女  | 深圳       |

|    ID  |   UID |   money
|------  |------ | --------
|     1  |    41 |     10000
|     2  |    45 |     20000
|     3  |    41 |     30000
- domain实体类
~~~java
public class User implements Serializable {

    private Integer id;
    private String username;
    private String address;
    private String sex;
    private Date birthday;
    
    private List<Account> accounts;   //一对多关系映射：主表实体应该包含从表实体的集合引用
    ...
}

public class Account implements Serializable {

    private Integer id;
    private Integer uid;
    private Double money;
    
    private User user;          //多对一关系：从表实体应该包含一个主表实体的对象引用
    ...
}
~~~
- dao层
~~~java
public Interface IUserDao{
  User findAllUsersWithAccountInfo();
  ...
}

public Interface IAccountDao{
  WorkExp findAllAccountsWithUserInfo();
  ...
}
~~~

- **多对一(一对一)：mapper中 使用association建立联系，javaType表示子结果封装的类型**
~~~xml
<mapper namespace="com.jj.dao.IAccountDao">

    <!-- 定义封装account和user的resultMap -->
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="aid"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>
        <!-- 多对一的关系映射：配置封装user的内容-->
        <association property="user" column="uid" javaType="user">
            <id property="id" column="id"></id>
            <result property="username" column="username"></result>
            <result property="address" column="address"></result>
            <result property="sex" column="sex"></result>
            <result property="birthday" column="birthday"></result>
        </association>
    </resultMap>

    <!-- 查询所有账户信息并附带其归属用户信息 -->
    <select id="findAllAccountsWithUserInfo" resultMap="accountUserMap">
        select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid;
    </select>
</mapper>
~~~

- **一对多：mapper中 使用collection建立联系，ofType表示结果集元素的封装类型**
~~~xml
<mapper namespace="com.jj.dao.IUserDao">

    <!-- 定义User的resultMap-->
    <resultMap id="userAccountMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>
        <!-- 配置user对象中accounts集合的映射 -->
        <collection property="accounts" ofType="account">
            <id property="id" column="aid"></id>
            <result property="uid" column="uid"></result>
            <result property="money" column="money"></result>
        </collection>
    </resultMap>

    <!-- 查询所有用户信息并附带其账户信息 -->
    <select id="findAllUsersWithAccountInfo" resultMap="userAccountMap">
        select u.*, a.id as aid, a.uid, a.money from user u left outer join account a on u.id = a.uid
    </select>
</mapper>
~~~

 - 多对多：两个实体都包含另一实体的集合引用，查询时需要借助中间表

## 9. MyBatis延迟加载
- 延迟加载(按需加载、懒加载)：需要使用数据时才发起查询，不用的数据不查询
- 立即加载：不管用不用，只要调用方法，马上发起查询

对于一对多或者多对多的情况，通常采用延迟加载                
对于一对一或者多对一的情况，通常采用立即加载

### 9.1 association，多对一延迟加载
- 主配置文件中开启延迟加载: `lazyLoadingEnabled`-> true，`aggressiveLazyLoading`-> false
~~~xml
<configuration>
    <!-- 配置properties-->
    <properties resource="jdbcConfig.properties"></properties>
    <settings>
        <!--打开延迟加载总开关-->
        <setting name="lazyLoadingEnabled" value="true"/>
        <!--将积极加载改为消息加载，即按需加载-->
        <setting name="aggressiveLazyLoading" value="false"/>
    </settings>
    ...
</configuration>
~~~

- Account的mapper中配置
~~~xml
<mapper namespace="com.jj.dao.IAccountDao">

    <!-- 定义封装account和user的resultMap -->
    <resultMap id="accountUserMap" type="account">
        <id property="id" column="id"></id>
        <result property="uid" column="uid"></result>
        <result property="money" column="money"></result>

        <!-- 一对一的关系映射：配置封装user的内容
             select属性指定查询用户的唯一标识
             column属性指定用户根据id查询时所需要的参数值 -->
        <association property="user" column="uid" javaType="user" select="com.jj.dao.IUserDao.findUserById">
        </association>

    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="accountUserMap">
        select * from account
    </select>

    <!--根据uid查询到账户-->
    <select id="findAccountByUid" parameterType="INT" resultType="account">
        select * from account where uid=#{uid};
    </select>

</mapper>
~~~

### 9.2 collection，一对多延迟加载
- 主配置文件开启延迟加载
- User 的mapper中的配置
~~~xml
<mapper namespace="com.jj.dao.IUserDao">

    <!-- 定义User的resultMap-->
    <resultMap id="userAccountMap" type="user">
        <id property="id" column="id"></id>
        <result property="username" column="username"></result>
        <result property="address" column="address"></result>
        <result property="sex" column="sex"></result>
        <result property="birthday" column="birthday"></result>

        <!-- 配置user对象中accounts集合的映射 -->
        <collection property="accounts" ofType="account" column="id" select="com.jj.dao.IAccountDao.findAccountByUid">
        </collection>

    </resultMap>

    <!-- 查询所有 -->
    <select id="findAll" resultMap="userAccountMap">
        select * from user
    </select>

    <!-- 根据id查询用户 -->
    <select id="findUserById" parameterType="INT" resultType="user">
        select * from user where id = #{id}
    </select>

</mapper>
~~~


## 10. MyBatis缓存

- 缓存可以减少和数据库的数据交换次数，提高执行效率
- **经常查询，不经常改变，并且数据的正确与否对最终结果影响不大**的数据才适合存放在缓存中
- MyBatis中有一级缓存和二级缓存
### 10.1 一级缓存
- MyBatis中的一级缓存指的是**SqlSession对象的缓存** 
- 当执行查询之后，查询的结果会同时存入到由 SqlSession 提供的一块内存区域中，该区域的结构是 **Map** 
- 当再次查询相同数据时，mybatis就会先去SqlSession中查询是否存在缓存，存在则直接拿来用
- 当**SqlSession对象消失时**，mybatis的一级缓存就消失了，还可以调用`sqlSession.clearCache()`来主动清空缓存
- 另外，当调用SqlSession的 **修改，添加，删除，commit()，close()** 等方法时，都将清空一级缓存
- 一级缓存直接**存放的是对象**，缓存存在时，**两次查询到的对象就是同一个对象**
### 10.2 二级缓存
- MyBatis中的二级缓存指的是 **SqlSessionFactory对象的缓存**， 由同一个 SqlSessionFactory 生产的  SqlSession 共享这一块二级缓存
- 二级缓存的生效需要对**MyBatis**的 `SqlMapConfig.xml` 和当前的 **映射文件** `Dao.xml` ，以及当前 **操作的select标签** 进行配置
- 二级缓存中**存放的是数据**，而不是对象，所以两次查询虽然使用了缓存，但是需要根据数据创建对象，所以**查询到的对象并不是同一个对象**
~~~xml
SqlMapConfig.xml中：
    <settings>
        <!--配置二级缓存-->
        <setting name="cacheEnabled" value="true"/>
    </settings>
~~~
~~~xml
IUserDao.xml中开启二级缓存，以及对select标签进行配置：
<mapper namespace="com.jj.dao.IUserDao">
    <!--开启user支持二级缓存-->
    <cache/>

    <!-- 根据id查询用户 -->
    <select id="findUserById" parameterType="INT" resultType="user" useCache="true">
        select * from user where id = #{id}
    </select>
</mapper>
~~~


## 11. 注解开发
![注解和xml的对应](https://s1.ax1x.com/2020/09/25/0C2oEF.png)
- MyBatis中针对CRUD一共由四种注解：**@Select、@Insert、@Update、@Delete**
- 使用注解开发时，不能再有 mapper 的xml配置文件，会报错
### 11.1 主配置文件的配置
- 配置实体类的别名，在从列到属性到对象的映射时才能找到相应的对象。直接配置为实体的包，之后所有的实体类的别名就是类名
- mappers使用 package 配置，直接配置到dao的包，以免每个dao都需要配置mapper
~~~xml
<configuration>
    <!--引入外部配置文件-->
    <properties resource="jdbcConfig.properties"></properties>

    <!--配置别名-->
    <typeAliases>
        <package name="com.jj.domain"/>
    </typeAliases>

    <!--配置环境-->
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!--指定映射的配置-->
    <mappers>
        <package name="com.jj.dao"/>
    </mappers>
</configuration>
~~~

### 11.2 关于模糊查询
注意两种模糊查询的方式
~~~java
//Dao：底层使用的是preparedStatement的参数占位符方式`?`
@Select("select * from user where username like #{username}")
List<User> findUserByName(String name);

//测试
List<User> users = userDao.findUserByName("%王%");
~~~

~~~java
//Dao：底层使用的是Statement方式的字符串拼接
@Select("select * from user where username like '%${value}%'")
List<User> findUserByName(String name);

//测试
List<User> users = userDao.findUserByName("王");
~~~

### 11.3 数据库字段到实体属性的映射

- 对于实体属性和数据库字段不对应的情况，mybatis提供了 `@Results` 字段的注解来配置映射
~~~java
//使用Results注解配置数据库字段到属性的映射
@Select("select * from user")
@Results( value={
    @Result(id=true, column="id", property="userId")
    @Result(column="username", property="userName")
    @Result(column="address", property="userAddress")
    @Result(column="sex", property="userSex")
    @Result(column="birthday", property="userBirthday")
})
List<User> findAll();
~~~

- 还可以给 `@Results` 提供唯一标识，之后使用 `@ResultMap` 通过value直接引用相应id的Results，避免每个查询都需要进行注解的属性和数据库字段映射配置，这也给多表查询提供了方法
~~~java
//Results注解，定义封装的映射userMap
@Select("select * from user")
@Results(id="userMap", value={
    @Result(id=true, column="id", property="userId")
    @Result(column="username", property="userName")
    @Result(column="address", property="userAddress")
    @Result(column="sex", property="userSex")
    @Result(column="birthday", property="userBirthday")
})
List<User> findAll();

//通过ResultMap的value字段直接使用之前定义的userMap
@Select("select * from user where username like #{username}")
@ResultMap(value={"userMap"})
List<User> findUserByName(String name);

//value字段也可以省略，而数组中只有一个元素，大括号也可以省略
@Select("select * from user where id=#{id}")
@ResultMap("userMap")
List<User> findUserById(int id);
~~~
### 11.4 注解实现多表查询
1. 多对一，一对一：     
通过`Result` 配置再映射         
`one`属性表示对一，`select`属性配置用于查询的Dao的方法，`fetchType`可以设置为立即加载
~~~java
public interface IAccountDao {
    @Select("select * from account")
    @Results(id="accountMap", value={
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "uid", property = "uid"),
            @Result(column = "money", property = "money"),
            @Result(column = "uid", property = "user",
                    one=@One(select="com.jj.dao.IUserDao.findById", 
                    fetchType= FetchType.EAGER))
    })
    List<Account> findAll();

    @Select("select * from account where uid = #{uid}")
    List<Account> findByUid(int uid);
}
~~~

2. 一对多： 
通过`Result` 配置再映射         
`many`属性表示对多，`select`属性配置用于查询的Dao的方法，`fetchType`可以设置为懒加载
~~~java
public interface IUserDao {
    @Select("select * from user")
    @Results(id="userMap", value={
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "username", property = "username"),
            @Result(column = "address", property = "address"),
            @Result(column = "sex", property = "sex"),
            @Result(column = "birthday", property = "birthday"),
            @Result(column = "id", property = "accounts",
                    many = @Many(select = "com.jj.dao.IAccountDao.findByUid", 
                    fetchType = FetchType.LAZY))
    })
    List<User> findAll();

    @Select("select * from user where id=#{id}")
    User findById(int id);
}
~~~
### 11.5 注解开启缓存
- 一级缓存`session`无需配置，可以直接使用
- 二级缓存`sessionFactory`需要配置以开启
首先需要在MyBatis的主配置文件 SqlMapConfig.xml 中配置开启缓存
~~~xml
    <settings>
        <!--配置二级缓存-->
        <setting name="cacheEnabled" value="true"/>
    </settings>
~~~

然后使用注解的方式对Dao配置`@CacheNameSpace`注解的`blocking`属性为true即可
~~~java
@CacheNamespace(blocking = true)
public interface IUserDao {
    ....
}
~~~

# Spring
## 1. Spring简介
**Spring的核心：** **IoC**（Inverse Of Control 反转控制）、**AOP**（Aspect Oriented Programming 面向切面编程）
Spring 提供了**表现层Spring MVC** 和**持久层 Spring JDBC** 以及**业务层事务管理**等众多的企业级应用技术，还整合开源世界众多著名的第三方框架和库类，逐渐成为使用最多的Java EE企业应用开源框架
**Spring的优势：** 解耦，简化开发；AOP 编程，实现传统OOP不易实现的功能；声明式事务的支持；方便测试；方便对各种优秀框架的支持(Structs,Hibernate,Hessian等)；降低JavaEE API的使用难度，如JDBC、JavaMail等


### 1.1 Spring体系结构
Spring体系结构
![Spring体系结构](https://s1.ax1x.com/2020/09/14/wDMp8S.gif)
## 2. 解耦和IoC
### 2.1 解耦
在以前的开发中，业务层调用持久层需要new持久层接口，表现层调用业务层业务要new持久层的接口，这就导致程序之间的高度耦合
**解耦就是要降低程序间的依赖关系**
在实际开发中应该做到：**编译器不依赖，运行时才依赖**
解耦的思路：
1. 使用反射创建对象，而避免使用new关键字(避免编译时错误)
2. 通过读取配置文件来获取要创建对象的全限定类名(避免频繁修改代码)

### 2.2 IoC
- 使用工厂来获得对象，工厂初始化时在内部将配置文件中的对象全部创建并保存到容器`Beans`中，获取时每次都获取到的是之前创建好的同一个对象(单例模式)
- **控制翻转(IoC)** 就是将创建对象的权力交给框架。它包括**依赖注入DI(Dependency Injection)** 和 **依赖查找DL(Dependency Lookup)**。IoC的作用就是削减程序的耦合

### 2.3 核心容器
- 核心容器用于存储Bean对象
~~~java
        /**
         *  获取spring的IoC核心容器，根据对象的id来获取对象
        */
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //获取核心容器对象
        IAccountService as = (IAccountService) ac.getBean("accountService");    //获取对象，直接强转
        IAccountDao adao= ac.getBean("accountDao", IAccountDao.class);  //通过传入对应的class来获取对象
~~~

**ApplicationContext的三个常用实现类：** 
- `ClassPathXmlApplicationContext`：可以加载类路径下的配置文件
- `FileSystemXmlApplicationContext`：可以加载磁盘路径下有访问权限的任意路径下的配置文件(不常用)
- `AnnotationConfigApplicationContext`：用于读取注解创建容器

**ApplicationContext和BeanFactory的区别：**
- `ApplicationContext`构建核心容器时，创建对象是采用立即加载的方式，效率高，占资源，单例对象适用（也可以手动设置Bean为延迟加载）
- `BeanFactory`构建核心容器时，创建对象是采用延迟加载(懒加载)的方式，效率低，省资源，多例对象适用

### 2.4 Spring对Bean的管理
**使用xml配置的方式，需要对xml进行配置**，`xmlns`
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

    </beans>
~~~
**使用注解配置的方式，需要对xml进行配置**，`xml:context`
~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    
    <!--告知spring在创建容器时要扫描的包路径-->
    <context:component-scan base-package="com.jj"/>

</beans>
~~~
#### 2.4.1 Bean对象创建的控制
- **基于xml的配置**
  - **使用默认构造函数构造：** 直接配置id(创建对象的类型)和class属性，且没有其他属性和标签。此时如果类中没有默认构造函数，则无法创建对象
    ~~~xml
        <bean id="accountService" class="com.jj.service.impl.AccountServiceImpl"></bean>
    ~~~
  
  - **使用类的方法创建对象，并存入spring容器：** 首先创建对应类的对象(工厂)，然后使用该对象的方法创建所需要的对象。配置id(创建的对象)，factory-bean(创建对象的工厂类)，factory-method(所使用的方法)
    ~~~xml
        <bean id="instanceFactory" class="com.jj.factory.InstanceFactory"></bean>
        <bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"></bean>
    ~~~
  - **使用类的静态方法创建对象，并存入spring容器：** 配置id，class 和 factory-method 即可
    ~~~xml
        <bean id="accountService" class="com.jj.factory.StaticFactory" factory-method="getAccountService"></bean>
    ~~~
- **基于注解的配置**
  - `@Component` 属性value用于配置bean的id。不写时默认是首字母变小写的当前类名 
    ~~~java
        @Component  //默认配置的bean的id是accountServiceImpl
        public class AccountServiceImpl implements IAccountService {...}
    
        @Component("accountService")  //配置value字段(value可省略不写)
        public class AccountServiceImpl implements IAccountService {...}
    ~~~
  - `@Controllor`(表现层)、`@Service`(业务层)、`@Repository`(持久层) ：这三个注解是spring框架提供的基于三层架构的注解，使三层对象更加清晰


#### 2.4.2 Bean对象的作用范围：

- 通过`bean`标签的`scope`属性进行设置    
    ~~~xml
        <bean id="accountService" class="com.jj.service.impl.AccountServiceImpl" scope="prototype"></bean>
    ~~~
   - `singleton`：单例（默认值）
   - `prototype`：多例
   - `request`：作用于web应用的请求范围
   - `session`：作用于web应用的会话范围
   - `global-session`：作用于集群环境的会话范围(全局会话范围)，当不是集群环境时，就用session
- 通过`Scope`注解进行配置，默认是单例的
    ~~~java
    @Service("accountService")
    @Scope("prototype")
    public class AccountServiceImpl implements IAccountService {...}
    ~~~

#### 2.4.3 Bean对象的生命周期：
- 单例对象：当容器创建时对象出生，容器销毁时对象消亡。单例对象的生命周期和容器相同
- 多例对象：当使用对象时对象出生，当对象长时间不用且没有别的对象引用时，由java的垃圾回收器回收

容器`ClassPathXmlApplicationContext`**调用close()方法销毁时，单例对象被销毁。多例对象是不受spring控制的**
- 在xml中配置`<bean>`标签的`init-method`和`destroy-method`属性可以用于指定初始化方法的销毁方法
- 或者使用`@PostConstruct`和`@PreDestroy`注解来分别用于指定初始化方法和销毁方法

还可以使用`@Lazy`注解，使spring延迟创建单例对象(在使用这个对象的时候，再创建这个对象)
#### 2.4.4 spring中的依赖注入
**依赖注入DI(Dependency Injection)：** IoC的作用是降低耦合，但是必然还是会存在一些耦合，这些耦合的依赖关系都交由spring来维护，**依赖关系的维护就是依赖注入**        
**能注入的数据类型：** 基本类型和String、其他的Bean类型、复杂类型(集合类型)         
**依赖注入的三种方式：** 构造函数、set方法、注解        
**经常变化的数据不适用于注入的方式** 
1. 构造函数注入(不常用)：使用`constructor-arg`标签进行配置。必须有对应参数个数的构造函数
   - type: 给构造函数中指定类型的参数赋值(构造函数中该参数的类型)
   - index：给构造函数中的指定索引位置的参数赋值，索引从0开始
   - **name：给构造函数中的指定名称参数赋值(常用)**
   - **value：用于指定基本类型和String类型的值**
   - **ref：用于指定其他的bean类型数据，引用的必须是在spring的IoC核心容器中出现过的bean对象**
    ~~~xml
    <bean id="accountService" class="com.jj.service.impl.AccountServiceImpl">
        <constructor-arg name="name" value="张三"></constructor-arg>
        <constructor-arg name="age" value="18"></constructor-arg>
        <constructor-arg name="birthday" ref="now"></constructor-arg>
    </bean>
    <!--配置一个日期对象-->
    <bean id="now" class="java.util.Date"></bean>
    ~~~
    ~~~java
    public AccountServiceImpl(String name, Integer age, Date birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }
    ~~~
2. **set方法注入(常用)：** 使用`property`标签进行配置。可以使用默认的无参构造，然后根据需要来配置属性
   - **name：指定注入时调用的set方法名称(属性名)**
   - **value：指定基本类型和String类型的值**
   - **ref：指定其他的bean类型数据，引用的必须是在spring的IoC核心容器中出现过的bean对象**
    ~~~xml
    <bean id="accountService" class="com.jj.service.impl.AccountServiceImpl">
        <property name="name" value="zhangsan"></property>
        <property name="age" value="11"></property>
        <property name="birthday" ref="now"></property>
    </bean>
   
    <bean id="now" class="java.util.Date"></bean>
    ~~~
3. **注解注入：** 
    总共有四种注解注入方式，`@Autowired`、`@Qualifier`、`@Resource`只能对其他bean类型进行注入，`@Value`可以进行基本类型和String类型的注入，而集合类型只能通过xml方式注入
   - `@Autowired`（可以写在变量上和方法上）：自动按照类型进行注入，只要容器中**有唯一的bean对象数据类型**和要注入的变量类型匹配就可以注入成功。如果容器中有**多个bean对象数据类型和要注入的变量类型匹配**成功，则**再按照变量名称进行匹配**，如果无法匹配则无法注入，会报错（可以通过设置`required`属性为false，使spring没有找到匹配的bean时也不抛出异常）。**这种注入方式不需要set方法**
    ![自动按照类型注入](https://s1.ax1x.com/2020/10/02/0l4r8S.png)
   - `@Qualifier`：在按照类型注入的基础之上再按照名称注入。它**在给类成员注入时不能单独使用！！！在给方法参数注入时可以单独使用**。value用于指定注入类型的id
    ~~~java
    @Repository("accountDao")
    public class AccountDaoImpl implements IAccountDao {...}
    
    @Repository("accountDao2")
    public class AccountDaoImpl2 implements IAccountDao {...}
    
    @Component("accountService")
    public class AccountServiceImpl implements IAccountService {
        ...
        @Autowired  //必须配合Autowired，先按照类型查找，再按照变量名查找
        @Qualifier("accountDao2")
        private IAccountDao accountDao;
    
        public void saveAccount() {accountDao.saveAccount();}
    
        //或者直接对方法进行注入
        //方法注入时会自动按照类型注入，无需加@Autowired
        public saveAccount(@Qualifier("accountDao2") IAccountDao accountDao) {accountDao.saveAccount();}
        ...
    }
    ~~~
   - `@Resource`：可以直接按照bean的id注入，通过name属性指定bean的id，可以独立使用
    ~~~java
    @Repository("accountDao")
    public class AccountDaoImpl implements IAccountDao {...}
    
    @Repository("accountDao2")
    public class AccountDaoImpl2 implements IAccountDao {...}
    
    @Component("accountService")
    public class AccountServiceImpl implements IAccountService {
        ...
        @Resource(name="accountDao2")    //直接通过name配置id即可
        private IAccountDao accountDao;
    
        public void saveAccount() {accountDao.saveAccount();}
        ...
    }
    ~~~
    - `@Value`：用于注入基本类型和String类型的数据。value属性用于指定数据的值。可以使用spring中的SpEL：`${表达式}`

4. 关于复杂类型的注入(集合类型)：**集合类型注入基本类型只能通过xml方式实现**，但是可以通过`@Autowired`注入bean对象作为集合元素(按照集合元素泛型进行注入)，对于Map，spring会将service的名字作为key，bean对象作为value封装进去
- **对于array、list、set类型的标签可以混用，对于map和properties也可以混用**，这两组标签内部用哪个都无所谓
- **但是要注意map标签和props标签内部写法的区别** 
~~~xml
    <bean id="accountService" class="com.jj.service.impl.AccountServiceImpl">
        <property name="myStrs">
            <array>
                <value>AA</value>
                <value>BB</value>
            </array>
        </property>

        <property name="myList">
            <set>
                <value>AA</value>
                <value>BB</value>
            </set>
        </property>

        <property name="mySet">
            <list>
                <value>AA</value>
                <value>BB</value>
            </list>
        </property>
        
        <property name="myMap">
            <map>
                <entry key="key1" value="value1"></entry>
            </map>
        </property>
        
        <property name="myProperties">
            <props>
                <prop key="propkey1">propvalue1</prop>
            </props>
        </property>
    </bean>
~~~

5. 其他注解
- 对于bean.xml配置文件中的信息，可以完全用注解来实现，不过需要额外定义一个配置类，加上`@Configuration`注解表明该类是注解类。当配置类作为`AnnotationConfigApplicationContext`的参数时，可以不加该注释
- `@ComponentScan`：指定spring在创建容器时要扫描的包，通过`basePackages`或`value`属性来指定
- `@Import`：用于导入其他的配置类(value属性用于指定对应配置的class即可)，有Import注解的类是父配置类(主配置类)，可以导入多个子配置类。同时`AnnotationConfigApplicationContext`的参数也支持多个父配置类
- `@PropertySource`：指定properties文件的位置。classpath表示在类路径下(`main/java/resources`)
- `@Bean`：把当前方法的返回值作为bean对象存入spring容器。通过name属性指定bean的id，**默认值是当前方法的名称**
- 使用注解时，Application的获取方法：`ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);`
~~~java
//@Configuration
@ComponentScan(basePackages={"com.jj"}) //指定spring创建容器时要扫描的包
@Import(JdbcConfig.class)   //导入配置文件
@PropertySource("classpath:jdbcConfig.properties")  //指定properties文件的位置
public class SpringConfiguration{

}

public class JdbcConfig{
    @Value("${jdbc.driver}")
    private String driver;
    
    @Value("${jdbc.url}")
    private String url;
    
    @Value("${jdbc.username}")
    private String username;
    
    @Value("${jdbc.password}")
    private String password;
    
    @Bean(name="runner")
    public QueryRunner createQueryRunner(DataSource dataSource){
        return new QueryRunner(dataSource);
    }

    @Bean(name="dataSource")
    public DataSource createDataSource(){
        ComboPooledDataSource ds = new ComboPooledDataSource();
        ds.setDriver(driver);
        ds.setJdbcUrl(url);
        ds.setUser(username);
        ds.setPassword(password);
        return ds;
    }
}
~~~
- 使用`@Bean`注解来实现通过工厂创建对象
~~~java
public class client{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
        IAccountService as = (IAccountService)ac.getBean("accountService");
    }
}
    
@Component
public class InstanceFactory {

    @Bean(name="accountService")
    @Scope("prototype")
    public IAccountService getAccountService(){
        System.out.println("factory中的accountService");
        return new AccountServiceImpl();
    }
}
~~~
- 对于jar包，还是得使用xml配置比较方便
#### 2.4.5 @Bean的“full”模式和“lite”模式
- full模式：@Bean注解在@Configuration类中声明，称之为“full”模式
- lite模式：@Bean注解和@Component注解组合使用时，称之为“lite”模式

区别：
lite模式下 @Bean方法互相调用无法声明Bean之间的依赖关系。即，bean中的对象只是普通对象，并不是spring容器中的bean。
如果要用@Bean和@Component注解组合完成bean之间的相互依赖注入的话，推荐采用构造方法或方法级别的依赖注入


#### 2.4.6 spring整合junit
- 导入依赖坐标：spring-test
- 使用`@RunWith`注解把junit原本的main方法替换成spring提供的`SpringJUnit4ClassRunner.class`
- 使用`@ContextConfiguration`注解配置spring的配置方式：
  - `locations`属性：指定xml文件的位置，加上classpath关键字，表示在类路径下
  - `classes`属性：指定注解类所在的位置
~~~java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=com.jj.config.SpringConfig.class)
public class Client {

    @Autowired
    IAccountService as;

    @Test
    public void testSave(){
        //获取spring的IoC核心容器，根据id获取对象
        ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);
        IAccountService as = (IAccountService) ac.getBean("accountService");    //直接强转

        //System.out.println(as);
        as.saveAccount();
    }
}
~~~

#### 2.4.7 配置中引入properties文件

- xml中引入，抽取jdbc配置文件
~~~xml
<context:property-placeholder location="classpath:jdbcConfig.properties">
~~~

- java配置类中引入
~~~java
@PropertySource("classpath:jdbcConfig.properties")  //指定properties文件的位置
public class SpringConfiguration{
}
~~~

### 2.5 循环依赖问题
创建A对象需要B，创建B对象需要A
解决办法：三级缓存。实例化和初始化分开处理，提前暴露对象
对于实例化的对象，放入三级缓存(Map)中，

## 3. AOP编程

### 3.1 转账案例
![转账案例](https://s1.ax1x.com/2020/10/03/08Cv7R.png)

#### 3.1.1 转账案例的问题
- 需要多次于数据库进行交互（共四次），成功的交互提交了，最后一次不成功不提交，未保持事务的一致性
- 所以需要ThreadLocal对象把Connection和当前线程绑定，从而使一个线程中只有一个能控制事务的对象。保证多次操作使用一个事务，要么都发生，要么都不发生
- 事务的控制应该放到持久层

#### 3.1.2 使用ThreadLocal绑定连接
~~~java
public class ConnectionUtils {
    private ThreadLocal<Connection> tl = new ThreadLocal<Connection>();
    private DataSource dataSource;
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    //获取当前线程上的连接
    public Connection getThreadConnection() {
        try{
            //1.先从ThreadLocal上获取
            Connection conn = tl.get();
            //2.判断当前线程上是否有连接
            if (conn == null) {
                //3.从数据源中获取一个连接，并且存入ThreadLocal中
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            //4.返回当前线程上的连接
            return conn;
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    //把连接和线程解绑
    public void removeConnection(){
        tl.remove();
    }
}
~~~

#### 3.1.3 事务的管理
~~~java
public class TransactionManager {
    private ConnectionUtils connectionUtils;

    public void setConnectionUtils(ConnectionUtils connectionUtils) {
        this.connectionUtils = connectionUtils;
    }

    //开启事务

    public  void beginTransaction(){
        try {
            connectionUtils.getThreadConnection().setAutoCommit(false);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    //提交事务
    public  void commit(){
        try {
            connectionUtils.getThreadConnection().commit();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    //回滚事务
    public  void rollback(){
        try {
            connectionUtils.getThreadConnection().rollback();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    //释放连接
    public  void release(){
        try {
            connectionUtils.getThreadConnection().close();//还回连接池中
            connectionUtils.removeConnection(); //把连接和线程解绑
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
~~~

#### 3.1.4 带事务的Service
- 对每个Service都进行事务的支持
~~~java
    public void transfer(String sourceName, String targetName, Float money) {
        try {
            //1.开启事务
            txManager.beginTransaction();
            //2.执行操作
            //2.1根据名称查询转出账户
            Account source = accountDao.findAccountByName(sourceName);
            //2.2根据名称查询转入账户
            Account target = accountDao.findAccountByName(targetName);
            //2.3转出账户减钱
            source.setMoney(source.getMoney()-money);
            //2.4转入账户加钱
            target.setMoney(target.getMoney()+money);
            //2.5更新转出账户
            accountDao.updateAccount(source);

            int i=1/0;

            //2.6更新转入账户
            accountDao.updateAccount(target);
            //3.提交事务
            txManager.commit();

        }catch (Exception e){
            //4.回滚操作
            txManager.rollback();
            e.printStackTrace();
        }finally {
            //5.释放连接
            txManager.release();
        }
    }
    ...
~~~
- 这样会产生很多的冗余代码，而AOP就是解决这一问题：把重复的逻辑代码横切出来，融合到业务逻辑中，来完成和之前(没抽取前)一样的功能。spring底层其实就是通过动态代理来实现AOP的功能
#### 3.1.5 cglib 基于子类的动态代理
使用`cglib`库来实现。针对于没有实现接口的类的动态代理。**CGLib代理其生成的动态代理对象是目标类的子类**
**Spring AOP默认是使用JDK动态代理，如果代理的类没有接口则会使用CGLib代理**          
- 使用`Enhancer`类中的`create`方法创建代理对象，**要求被代理对象和方法不能是final的**
- `create`方法的参数：`Class`是被代理对象的字节码，`Callback`是增强的代码(一般用其实现类`MethodInterceptor`)
~~~java
        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {
            /**
             * 执行被代理对象的任何方法都会经过该方法
             * @param proxy
             * @param method
             * @param args
             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的
             * @param methodProxy ：当前执行方法的代理对象
             * @return
             * @throws Throwable
             */
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                //提供增强的代码
                Object returnValue = null;

                //1.获取方法执行的参数
                Float money = (Float)args[0];
                //2.判断当前方法是不是销售
                if("saleProduct".equals(method.getName())) {
                    returnValue = method.invoke(producer, money*0.8f);
                }
                return returnValue;
            }
        });
~~~

### 3.2 AOP相关概念
- AOP即面向切片编程。通过**预编译**的方式和**运行期动态代理**实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的热点，也是spring框架的重要内容，是函数式编程的一种衍生泛型。
- 利用AOP可以**对业务逻辑的各个部分进行隔离**，从**而使业务逻辑各部分之间的耦合度降低**，**提高程序的可用性**。即减少重复代码，提高开发效率，维护方便
- 简单的说就是**把程序中重复代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有方法进行增强**
- AOP的实现方式就是动态代理
- **连接点(Join point)：** 连接点是一个应用执行过程中能够插入一个切面的点，也就是那些可以被拦截到的点。spring AOP是基于动态代理的，所以是方法拦截的，每个成员方法都可以称之为拦截点
- **切点(Pointcut)：** 切点就是实际进行拦截的那些Joinpoint

- **通知/增强(Advice)：** 通知就是具体添加到切点的一段逻辑代码，并定位连接点的方位信息(**做什么，在哪儿做**)。Spring AOP提供了5中Advice：前置通知、后置通知、异常通知、最终通知(返回通知)、环绕通知。`aop:before`,`aop:after-returning`(后置通知，正常返回通知),`aop:after-throwing`,`aop:after`(返回通知，最终通知),`aop:around`。五种通知的执行顺序为： 前置通知→环绕通知→正常返回通知/异常返回通知→返回通知。后置通知不会和异常通知同时执行
![通知的类型](https://s1.ax1x.com/2020/10/04/0GiX4I.jpg)

- **引介(Introduction)：** 一种特殊的通知，在不修改代码的前提下，引介可以**在运行期为类动态的添加一些方法或Field**
- **目标对象(Target)：** 代理的目标对象
- **织入(Weaving)：** 把 增强/通知 应用到目标对象的具体连接点来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入
- **代理(Proxy)：** 一个类被AOP织入增强后，就产生一个结果代理类
- **切面(Aspect)：** 切点和通知(引介)的结合

### 3.3 spring中AOP的配置
Spring提供了三种类型的AOP支持：

- **基于代理的经典SpringAOP：** 需要实现接口，手动创建代理
- **纯POJO切面：** 使用XML配置，aop命名空间
- **@AspectJ注解驱动的切面：** 使用注解的方式，这是最简洁和最方便的

#### 3.3.1 基于xml的配置

1. 把从公共代码抽取的类的bean交给spring管理
2. 使用`aop:config`标签开始AOP的配置，`proxy-target-class="true"`可以配置cglib代理
3. 使用`aop:aspect`标签配置切面：id属性给切面提供唯一标识，ref属性引用`bean`
4. 在aop:aspect标签内部配置通知：`aop:before`,`aop:after-returning`(后置通知，正常返回通知),`aop:after-throwing`,`aop:after`(返回通知，最终通知),`aop:around`。五种通知的执行顺序为： 前置通知→环绕通知→正常返回通知/异常返回通知→返回通知
   - `method`属性：指定ref引用的bean中的哪个方法是用于该通知的
   - `pointcut`属性：指定切入点表达式。对业务层中哪些方法进行增强。

**切入点表达式的写法：**
切入点表达式需要 aspectJ 进行解析
标准写法：`修饰符 返回值 全限定类名.方法名(参数列表)`
全通配写法：`* *..*.*(..)`，即省略修饰符，通配返回值和类名方法名(*通配参数，..表示有无参数都行)
常用写法：`* com.jj.service.impl.*.*(..)` 通配业务层的方法
- 直接执行的通知方法：`execution(修饰符 全限定类名.方法)`
![配置切面](https://s1.ax1x.com/2020/10/04/0G3vwR.png)
也可以配置`aop:pointcut`，通过`pointcut-ref`直接进行引用
![配置pointcut](https://s1.ax1x.com/2020/10/04/0G3jm9.png)
需要注意的是，一旦配置了环绕通知，切入点方法便不再执行了，直接按前置通知→环绕通知→正常返回通知/异常返回通知→返回通知的顺序执行通知。
解决：spring提供了接口`ProceedingJoinPoint`，该接口的方法`proceed()`就相当于明确调用切点方法，该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会提供该接口的实现类。**环绕通知其实就是spring提供的一种可以在代码中手动控制增强方法何时执行的方式**
~~~java
    public Object printLogAround(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try {
            Object[] args = pjp.getArgs();  //获取参数

            System.out.println("手动控制前置通知");
            
            rtValue = pjp.proceed(args);//明确调用切入点方法
            
            System.out.println("手动控制后置通知");
            return rtValue;
        } catch (Throwable throwable) {
            System.out.println("手动控制异常通知");
            throwable.printStackTrace();
        } finally{
            System.out.println("手动控制最终通知");
        }
        return rtValue;
    }
/** Logger类中的printLog方法开始记录日志了。。。
  * 手动控制前置通知
  * 执行了更新1
  * 手动控制后置通知
  * 手动控制最终通知
  * Logger类中的printLogAfterReturn方法开始记录日志了。。。
  * Logger类中的printLogAfter方法开始记录日志了。。。
 */

~~~

- 增强参数：
- 增强返回值：

#### 3.3.2 基于注解的配置
xml中导入context头。开启注解spring对注解AOP的支持
~~~xml
    <!--配置spring开启注解AOP支持-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
~~~

- 值得注意的是，注解中 `@After` 是后置通知，`@AfterReturning` 是最终通知，使用环绕通知就可以避免顺序错乱的问题
~~~java
@Component("logger")
@Aspect //当前类是个切面类
public class Logger {
    @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
    public void pt1(){}

    @Before("pt1()")
    public  void printLog(){
        System.out.println("前置：Logger类中的printLog方法开始记录日志了。。。");
    }

    @AfterReturning("pt1()")
    public void printLogAfterReturn(){
        System.out.println("Logger类中的printLogAfterReturn方法开始记录日志了。。。");
    }

    @AfterThrowing("pt1()")
    public void printLogAfterThrow(){
        System.out.println("异常：Logger类中的printLogAfterThrow方法开始记录日志了。。。");
    }

    @After("pt1()")
    public void printLogAfter(){
        System.out.println("Logger类中的printLogAfter方法开始记录日志了。。。");
    }
}
/** 前置：Logger类中的printLog方法开始记录日志了。。。
  * 执行了更新1
  * Logger类中的printLogAfter方法开始记录日志了。。。                      @After是后置通知
  * Logger类中的printLogAfterReturn方法开始记录日志了。。。                @AfterReturn是最终通知
 */
~~~

## 4. spring中的JdbcTemplate
`JdbcTemplate`是spring框架提供的一个对象，是对原始Jdbc API对象的简单封装。spring提供了许多操作的模板类
- 操作关系型数据库的：`JdbcTemplate`、`HibernateTemplate`
- 操作nosql数据库的：`RedisTemplate`
- 操作消息队列的：`JmsTemplate`

JdbcTemplate在`spring-jdbc-5.0.2.RELEASE.jar`包中，同时需要和事务相关的依赖jar包`spring-tx-5.0.2.RELEASE.jar`

### 4.1 JdbcTemplate的用法
~~~java
        //设置数据源
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/mydb");
        ds.setUsername("root");
        ds.setPassword("root");

        //使用JdbcTemplate操作数据库
        JdbcTemplate jt = new JdbcTemplate();
        jt.setDataSource(ds);
        jt.execute("insert into account(id,name,money) values(1,'王五',1234.1)");
~~~

### 4.2 使用spring管理bean
~~~xml
    <bean id="driverManagerDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="${jdbc.driverClassName}"></property>
        <property name="url" value="${jdbc.url}"></property>
        <property name="username" value="${jdbc.username}"></property>
        <property name="password" value="${jdbc.password}"></property>
    </bean>
~~~

### 4.3 JdbcTemplate的CRUD
~~~java
        //1.获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.获取对象
        JdbcTemplate jt = ac.getBean("jdbcTemplate",JdbcTemplate.class);
        //3.执行操作

        //保存
        jt.update("insert into account(name,money)values(?,?)","eee",3333f);
        
        //更新
        jt.update("update account set name=?,money=? where id=?","test",4567,7);
        
        //删除
        jt.update("delete from account where id=?",8);
        
        //查询所有
        List<Account> accounts = jt.query("select * from account where money > ?",new BeanPropertyRowMapper<Account>(Account.class),1000f);
        
        //查询一个：直接使用查询所有的方法来，通过get(0)获取第一个对象即可
        List<Account> accounts = jt.query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),1);
        System.out.println(accounts.isEmpty()?"没有内容":accounts.get(0));

        //查询返回一行一列（使用聚合函数，但不加group by子句）
        Long count = jt.queryForObject("select count(*) from account where money > ?",Long.class,1000f);
~~~

### 4.4 spring配置的相关说明
- Dao 直接继承 `JdbcDaoSupport`，这个父类含有 `jdbcTemplate` 属性和`get`方法，省去了重复代码，同时该jdbcTemplate既可以根据`datasource`来创建，又可以直接注入含有datasource的`template`
~~~java
public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {

    public Account findAccountById(Integer id) {
        //使用父类的getJdbcTemplate()方法直接获得jdbcTemplate对象
        List<Account> accounts = getJdbcTemplate().query("select * from account where id=?", new BeanPropertyRowMapper<Account>(Account.class), id);
        return accounts.isEmpty()?null:accounts.get(0);
    }

    public Account findAccountByName(String name) {
        List<Account> accounts = getJdbcTemplate().query("select * from account where name=?", new BeanPropertyRowMapper<Account>(Account.class), name);
        return accounts.isEmpty()?null:(accounts.get(0));
    }

    public void updateAccount(Account account) {
        getJdbcTemplate().update("update account set name=?,money=? where id=?", account.getName(), account.getMoney(), account.getId());
    }
}
~~~

~~~xml
    <bean id="driverManagerDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/mydb"></property>
        <property name="username" value="root"></property>
        <property name="password" value="root"></property>
    </bean>

    <!-- <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="driverManagerDataSource"></property>
    </bean> -->
    <bean id="accountDao" class="com.jj.dao.impl.AccountDaoImpl">
        <!-- 注入dataSource或者jdbcTemplate均可 -->
        <property name="dataSource" ref="driverManagerDataSource"></property>
    </bean>
~~~
## 5. spring的事务控制 
- spring框架提供了一组事务控制的接口，在`spring-tx-5.0.2.RELEASE.jar`中
- spring的事务控制都是基于AOP的，既可以使用编程的方式实现，也可以使用配置的方式实现

### 5.1 PlatformTransactionManager
`PlatformTransactionManager`提供了三个事务的操作
- 获取事务信息：`TransactionStatus getTransaction(TransactionDefinition definition)`
- 提交事务：`void commit(TransactionStatus status)`
- 回滚事务：`void rollback(TransactionStatus status)`

**真正管理事务的对象**：
- org.springframwork.jdbc.datasource.DataSourceTransactionManager 使用SpringJDBC或者iBatis进行持久化数据时使用
- org.springframwork.orm.hibernate5.HibernateTransactionManager 使用Hibernate版本进行持久化数据时使用

**TransactionDefinition**
TransactionDefinition是事务的定义信息对象，提供的方法：
- 获取事务对象名称：`String getName()`
- 获取事务隔离级别：`int getIsolationLevel()`
- 获取事务传播行为：`int getPropagationBehavior()`
- 获取事务超时时间：`int getTimeout()`
- 获取事务是否只读：`boolean  isReadOnly()` 只读型事务在执行查找时也会开启事务，读写型事务只在增删改时开启事务。建议查询设置只读，其他设置读写

**事务的隔离级别**
- ISOLATION_DEFAULT ： 默认级别
- ISOLATION_READ_UNCOMMITTED ： 可以读取未提交数据
- ISOLATION_READ_COMMITED ： 可以读取已提交数据
- ISOLATION_REPEATABLE_READ ： 可重复读(MySQL的默认级别)
- ISOLATION_SERIALIZABLE ： 读取其他事务提交添加后的数据，解决幻读

**TransactionStatus**
TransactionStatus接口描述了某个时间点上事务对象的状态信息，包含6个具体操作
- 刷新事务：`void flush()` 
- 是否存在存储点：`boolean hasSavePoint()`
- 事务是否已完成：`boolean isCompleted()`
- 是否是个新事务：`boolean isNewTransaction()`
- 事务是否回滚：　`boolean isRollbackOnly()`，设置事务回滚`void setRollbackOnly()`

### 5.5 xml方式配置事务管理
- 关于事务的属性
`isolation`：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。
`propagation`：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。
`read-only`：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。
`timeout`：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。
`rollback-for`：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。
`no-rollback-for`：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。
~~~xml
    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--配置事务的通知-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <!--配置事务属性-->
        <tx:attributes>
            <tx:method name="find*" propagation="SUPPORTS" read-only="true"></tx:method>
            <tx:method name="*" propagation="REQUIRED" read-only="false"/>
        </tx:attributes>
    </tx:advice>

    <!--配置AOP-->
    <aop:config>
        <aop:pointcut id="pt1" expression="execution(* com.jj.service.impl.*.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"></aop:advisor>
    </aop:config>
~~~

### 5.6 注解配置事务管理
~~~xml
    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--开启spring对注解事务的支持-->
    <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
~~~

~~~java
@Service("accountService")
@Transactional(propagation = Propagation.SUPPORTS, readOnly = true) //读操作配置只读
public class AccountServiceImpl implements IAccountService {

    @Autowired
    private IAccountDao accountDao;

    public Account findAccountById(int id) {
        return accountDao.findAccountById(id);
    }

    @Transactional(propagation = Propagation.REQUIRED, readOnly = false) //增删改操作配置有事务，非只读
    public void transfer(String fromName, String toName, Float money) {
        System.out.println("开始转账......");
        Account fromAccount = accountDao.findAccountByName(fromName);
        Account toAccount = accountDao.findAccountByName(toName);
        if(fromAccount.getMoney()<money){
            System.out.println("转出账户的余额不足，转账失败");
        } else {
            fromAccount.setMoney(fromAccount.getMoney()-money);
            toAccount.setMoney(toAccount.getMoney()+money);
            accountDao.updateAccount(fromAccount);
            int i = 1/0;
            accountDao.updateAccount(toAccount);
            System.out.println("转账"+money+"元，转账成功！");
        }
    }
}
~~~
### 5.7 全注解配置
配置configuration
~~~java
@Configuration
public class JdbcConfig {

    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean(name="jdbcTemplate")  //创建jdbcTemplate的bin
    public JdbcTemplate createTemplate(DataSource dataSource){
        return new JdbcTemplate(dataSource);
    }

    @Bean(name="dataSource")    //创建dataSource的bean
    public DataSource createDataSource(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
~~~

~~~java
@Configuration
public class TransactionConfig {
    @Bean(name="transactionManager")  //创建事务管理器
    public DataSourceTransactionManager getTransactionManager(@Autowired DataSource dataSource){
        return new DataSourceTransactionManager(dataSource);
    }
}
~~~

~~~java
@Configuration
@ComponentScan("com.jj")    //创建bean要扫描的包路径
@Import({JdbcConfig.class, TransactionConfig.class})
@PropertySource("jdbc.properties")  //properties文件
@EnableTransactionManagement    //开启事务的注解支持
public class SpringConfiguration {}
~~~

- 其他代码见工程 springJdbc

# Spring MVC
- 基于java的实现MVC设计模型的请求驱动类型的轻量级Web框架。通过一套注解，让一个简单的Java类成为处理请求的控制器，而无需实现任何接口(例如Servlet还需要继承HttpServlet)，同时它还支持RESTful编程风格的请求

**SpringMVC和Structs2** 
- 都是基于MVC模型的表现层框架，底层都是ServletAPI，处理请求的机制都是核心的控制器
- SpringMVC的入口是Servlet，Structs2的入口是Filter
- SpringMVC是基于方法设计的，Structs2是基于类(每次执行都会创建一个动作类，所以速度稍慢)
- SpringMVC更简洁，支持JSR303，处理ajax请求更方便
- Structs2的OGNL表达式使页面的开发效率比SpringMVC高，但是执行效率低，尤其是Structs2的表单标签，远没有html执行效率高

**创建webapp的一些注意事项**：
- 解决maven项目创建慢的问题，创建项目时添加键值对：`archetypeCatalog, internal`
- 版本锁定的方法：
~~~xml
  <!-- 版本锁定 -->
  <properties>
    <spring.version>5.0.2.RELEASE</spring.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>${spring.version}</version>
    </dependency>
  </dependencies>
~~~

**开启springMVC注解支持**
~~~xml
    <mvc:annotation-driven></mvc:annotation-driven>
~~~

## 1. QuickStart
- 导入相应坐标
- 配置SpringMVC核心控制器 DispatcherServlet
- 创建Controller类和视图页面
- 使用注解配置Controller类中业务方法的映射地址
- 配置SpringMVC的核心文件spring-mvc.xml
- 客户端发起请求测试

SpringMVC的执行流程
![springMVC](https://s3.ax1x.com/2020/11/28/Dy6ABQ.png)

## 2. 组件  

### 2.1 前端控制器
### 2.2 处理器映射器
### 2.3 处理器适配器
### 2.4 处理器
### 2.5 视图解析器


### 异常处理器

